<?php
// api/worker_flow.php - OMNI-ENGINE V29.5 (FAST-CHAINING ENGINE & EXCLUSIVE PRIORITY HANDLING - FINAL RACE CONDITION/BYPASS FIX)
// Engine này đã được tối ưu để xử lý liên tiếp các bước không có thời gian chờ.

error_reporting(E_ALL & ~E_DEPRECATED & ~E_NOTICE); 
ini_set('display_errors', 0);
set_time_limit(60); 

require_once 'db_connect.php';
require_once 'Mailer.php';

date_default_timezone_set('Asia/Ho_Chi_Minh');
$pdo->exec("SET NAMES utf8mb4 COLLATE utf8mb4_unicode_ci"); // Fix: Set correct collation

$isTestMode = isset($_GET['test_mode']) && $_GET['test_mode'] == '1'; 

$protocol = isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] === 'on' ? "https" : "http";
$apiUrl = "$protocol://".$_SERVER['HTTP_HOST'].dirname(dirname($_SERVER['PHP_SELF']));
$stmt = $pdo->query("SELECT * FROM system_settings");
$settings = [];
foreach ($stmt->fetchAll() as $row) { $settings[$row['key']] = $row['value']; }
$defaultSender = !empty($settings['smtp_user']) ? $settings['smtp_user'] : "marketing@ka-en.com.vn"; 
$mailer = new Mailer($pdo, $apiUrl, $defaultSender);

$now = date('Y-m-d H:i:s');
$currentTime = date('H:i');
$currentDayIdx = (date('w') == 0) ? 6 : date('w') - 1; 

$logs = [];
$logs[] = "--- FLOW WORKER START: $now ---";

// --- HELPERS (Replicated for self-sufficiency) ---
function parseLoopingContent($html, $context) {
    return preg_replace_callback('/<!-- START_ITEM_LOOP -->(.*?)<!-- END_ITEM_LOOP -->/s', function($matches) use ($context) {
        $template = $matches[1]; $output = ''; $items = $context['items'] ?? [];
        if (is_array($items) && count($items) > 0) {
            foreach ($items as $item) {
                $row = $template;
                foreach ($item as $key => $val) { $row = str_replace("{{item.$key}}", $val, $row); }
                $output .= $row;
            }
        }
        return $output;
    }, $html);
}

function resolveEmailContent($pdo, $templateId, $customHtml, $fallbackBody = '', $context = []) {
    $htmlContent = '';
    if ($templateId && $templateId !== 'custom-html') {
        $stmt = $pdo->prepare("SELECT html_content FROM templates WHERE id = ?");
        $stmt->execute([$templateId]);
        $htmlContent = $stmt->fetchColumn();
        if ($htmlContent && $fallbackBody && strpos($htmlContent, '{{body}}') !== false) {
            $htmlContent = str_replace('{{body}}', $fallbackBody, $htmlContent);
        }
    } elseif ($templateId === 'custom-html' || !empty($customHtml)) {
        $htmlContent = !empty($customHtml) ? $customHtml : $fallbackBody;
    } else { $htmlContent = $fallbackBody; }
    if (!$htmlContent) $htmlContent = "<html><body><p>(No Content)</p></body></html>";
    return parseLoopingContent($htmlContent, $context);
}

function replaceMergeTags($html, $subscriber, $context = []) {
    $firstName = $subscriber['first_name'] ?? ''; $lastName = $subscriber['last_name'] ?? '';
    $fullName = trim($firstName . ' ' . $lastName); $email = $subscriber['email'] ?? '';
    $map = [ '{{first_name}}' => $firstName, '{{last_name}}' => $lastName, '{{full_name}}' => $fullName ?: 'Bạn', '{{email}}' => $email, '{{company_name}}' => $subscriber['company_name'] ?? '', '{{phone}}' => $subscriber['phone_number'] ?? '', '{{job_title}}' => $subscriber['job_title'] ?? '', '{{year}}' => date('Y'), '{{date}}' => date('d/m/Y') ];
    foreach ($context as $key => $val) { if (is_string($val) || is_numeric($val)) { $map["{{$key}}"] = $val; } }
    return str_replace(array_keys($map), array_values($map), $html);
}

// FIX: Cập nhật hàm logActivity để bao gồm flow_id và campaign_id
function logActivity($pdo, $subscriberId, $type, $referenceId, $referenceName, $details, $flowId = null, $campaignId = null) {
    $stmtIns = $pdo->prepare("INSERT INTO subscriber_activity (subscriber_id, type, reference_id, flow_id, campaign_id, reference_name, details, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, NOW())");
    $stmtIns->execute([$subscriberId, $type, $referenceId, $flowId, $campaignId, $referenceName, $details]);
    $stmtCount = $pdo->prepare("SELECT COUNT(id) FROM subscriber_activity WHERE subscriber_id = ?");
    $stmtCount->execute([$subscriberId]);
    if ($stmtCount->fetchColumn() > 10) {
        $stmtDel = $pdo->prepare("DELETE FROM subscriber_activity WHERE subscriber_id = ? ORDER BY created_at ASC LIMIT 1");
        $stmtDel->execute([$subscriberId]);
    }
}

function isSubscriberMatch($sub, $criteriaJson) {
    if (empty($criteriaJson)) return true;
    $groups = json_decode($criteriaJson, true);
    if (!$groups || !is_array($groups)) return false;
    foreach ($groups as $group) {
        $groupMatch = true;
        if (!isset($group['conditions']) || !is_array($group['conditions'])) continue; // Skip if no conditions
        
        foreach ($group['conditions'] as $cond) {
            $field = $cond['field']; $op = $cond['operator']; $val = strtolower($cond['value'] ?? '');
            $actualVal = "";
            
            if (strpos($field, 'stats.') === 0) {
                $statKey = str_replace('stats.', '', $field);
                if ($statKey == 'emailsOpened') $actualVal = $sub['stats_opened'] ?? 0;
                else if ($statKey == 'linksClicked') $actualVal = $sub['stats_clicked'] ?? 0;
            } else if ($field === 'tags') {
                $subTags = json_decode($sub['tags'] ?? '[]', true); 
                if (!is_array($subTags)) $subTags = [];
                
                $isMatch = false;
                if ($op === 'contains') {
                    $isMatch = in_array(strtolower($val), array_map('strtolower', $subTags));
                } else if ($op === 'not_contains') {
                    $isMatch = !in_array(strtolower($val), array_map('strtolower', $subTags));
                }
                if (!$isMatch) { $groupMatch = false; break; }
                continue; 
            } else { 
                $actualVal = $sub[$field] ?? ""; 
            }
            
            $actualVal = (string)$actualVal;
            $isMatch = false;

            switch ($op) {
                case 'contains': 
                    if (strpos(strtolower($actualVal), $val) !== false) $isMatch = true; 
                    break;
                case 'not_contains': 
                    if (strpos(strtolower($actualVal), $val) === false) $isMatch = true; 
                    break;
                case 'equals': case 'is': 
                    if (strtolower($actualVal) == $val) $isMatch = true; 
                    break;
                case 'is_not': 
                    if (strtolower($actualVal) != $val) $isMatch = true; 
                    break;
                case 'starts_with': 
                    if (substr(strtolower($actualVal), 0, strlen($val)) === $val) $isMatch = true; 
                    break;
                case 'greater_than': 
                    if ((float)$actualVal > (float)$val) $isMatch = true; 
                    break;
                case 'less_than': 
                    if ((float)$actualVal < (float)$val) $isMatch = true; 
                    break;
                case 'after': 
                    if (strtotime($actualVal) > strtotime($val)) $isMatch = true; 
                    break;
                case 'before': 
                    if (strtotime($actualVal) < strtotime($val)) $isMatch = true; 
                    break;
                case 'on': 
                    if (date('Y-m-d', strtotime($actualVal)) === $val) $isMatch = true;
                    break;
            }
            
            if (!$isMatch) { $groupMatch = false; break; }
        }
        if ($groupMatch) return true;
    }
    return false;
}

// --- QUEUE FETCHING ---
$BATCH_SIZE = 50; 
$items = [];
$priorityQueueId = null;
// Detect if this is an exclusive priority run for a single queue item
$isPriorityRun = (isset($_GET['priority_queue_id']) && isset($_GET['priority_sub_id']) && isset($_GET['priority_flow_id']));
$isPriorityChain = $isPriorityRun; // If it's a priority run, then the entire chain of instant steps is priority

// Start a global transaction for the entire worker run
$pdo->beginTransaction(); 

try { // *** START OF GLOBAL TRY BLOCK ***
    // =================================================================================
    // 1. Check for EXCLUSIVE PRIORITY item (from worker_priority.php)
    //    If found, this worker run will ONLY process this item and then exit.
    // =================================================================================
    if ($isPriorityRun) {
        $priorityQueueId = $_GET['priority_queue_id'];
        $prioritySubId = $_GET['priority_sub_id'];
        $priorityFlowId = $_GET['priority_flow_id'];

        $logs[] = "[Flow-Priority] Received exclusive request for Queue ID: $priorityQueueId. Sub: $prioritySubId, Flow: $priorityFlowId.";

        // Select and lock the priority item, allowing to 'take over' if already processing by another worker
        $stmtPriority = $pdo->prepare("SELECT q.id as queue_id, q.subscriber_id, q.flow_id, q.step_id, q.created_at as queue_created_at, 
                                     f.steps as flow_steps, f.config as flow_config, f.name as flow_name, 
                                     s.email as sub_email, s.first_name, s.last_name, s.company_name, s.phone_number, s.job_title,
                                     s.status as sub_status, s.tags as sub_tags, s.id as sub_id, s.date_of_birth, s.anniversary_date,
                                     s.stats_opened, s.stats_clicked, s.last_open_at, s.last_click_at
                                     FROM subscriber_flow_states q 
                                     JOIN flows f ON q.flow_id = f.id 
                                     JOIN subscribers s ON q.subscriber_id = s.id 
                                     WHERE q.id = ? AND q.subscriber_id = ? AND q.flow_id = ? AND q.status IN ('waiting', 'processing') AND f.status = 'active'
                                     LIMIT 1 FOR UPDATE SKIP LOCKED"); 
        
        // This inner try-catch is for fetching and marking the priority item.
        // It's still valid to have nested transactions/try-catches, just ensure proper structure.
        try { 
            $stmtPriority->execute([$priorityQueueId, $prioritySubId, $priorityFlowId]);
            $priorityItem = $stmtPriority->fetch();

            if ($priorityItem) {
                $initialStatus = $priorityItem['status'];
                // Mark priority item as processing immediately
                $pdo->prepare("UPDATE subscriber_flow_states SET status = 'processing', updated_at = NOW() WHERE id = ?")->execute([$priorityQueueId]);
                $items[] = $priorityItem; // Add to the front of the list
                $logs[] = "[Flow-Priority] Item $priorityQueueId found. Initial status: '{$initialStatus}'. Now 'processing'.";
            } else {
                $logs[] = "[Flow-Priority] Item $priorityQueueId not found or not in 'waiting'/'processing' state.";
            }
        } catch (Exception $e) {
            // Log error, but do not rollback the outer transaction or exit here.
            // Let the outer catch/finally handle the full transaction.
            $logs[] = "[ERROR] Flow-Priority fetch failed for $priorityQueueId: " . $e->getMessage();
        }
    }


    // =================================================================================
    // 2. Fetch regular batch items (ONLY if not a priority-exclusive run)
    //    Includes stalled 'processing' items for self-healing.
    // =================================================================================
    if (!$isPriorityRun) { // Only fetch regular batch if not a priority run
        $sqlRegular = "SELECT q.id as queue_id, q.subscriber_id, q.flow_id, q.step_id, q.created_at as queue_created_at, 
                        f.steps as flow_steps, f.config as flow_config, f.name as flow_name, 
                        s.email as sub_email, s.first_name, s.last_name, s.company_name, s.phone_number, s.job_title,
                        s.status as sub_status, s.tags as sub_tags, s.id as sub_id, s.date_of_birth, s.anniversary_date,
                        s.stats_opened, s.stats_clicked, s.last_open_at, s.last_click_at
                        FROM subscriber_flow_states q 
                        JOIN flows f ON q.flow_id = f.id 
                        JOIN subscribers s ON q.subscriber_id = s.id 
                        WHERE (q.status = 'waiting' AND q.scheduled_at <= ?) OR 
                              (q.status = 'processing' AND q.updated_at < DATE_SUB(NOW(), INTERVAL 5 MINUTE))
                        AND f.status = 'active'
                        ORDER BY q.scheduled_at ASC, q.updated_at ASC LIMIT {$BATCH_SIZE} FOR UPDATE SKIP LOCKED";

        $stmtRegular = $pdo->prepare($sqlRegular);
        
        try { // This inner try-catch is for fetching and marking regular items.
            $stmtRegular->execute([$now]);
            $regularItems = $stmtRegular->fetchAll();
            
            if (!empty($regularItems)) {
                $queueIdsToMark = array_column($regularItems, 'queue_id');
                $placeholders = implode(',', array_fill(0, count($queueIdsToMark), '?'));
                $stmtMarkProcessing = $pdo->prepare("UPDATE subscriber_flow_states SET status = 'processing', updated_at = NOW() WHERE id IN ({$placeholders})"); 
                $stmtMarkProcessing->execute($queueIdsToMark);
                $items = array_merge($items, $regularItems);
                foreach($regularItems as $rItem) {
                    if ($rItem['status'] === 'processing') {
                        $logs[] = "[Flow-Regular] Re-picking stalled 'processing' item {$rItem['queue_id']} (Flow: {$rItem['flow_id']}, Sub: {$rItem['subscriber_id']}).";
                    }
                }
                $logs[] = "[Flow-Regular] Fetched " . count($regularItems) . " regular items and marked as 'processing'.";
            } else {
                 $logs[] = "[Flow-Regular] No regular items to process.";
            }
        } catch (Exception $e) {
            // Log error, but do not rollback the outer transaction or exit here.
            $logs[] = "[ERROR] Regular batch fetch failed: " . $e->getMessage();
        }
    }


    if (empty($items)) {
        $logs[] = "[Flow] No items to process. Exit.";
        $pdo->commit(); // Commit before exiting
        echo implode("\n", $logs);
        exit;
    }

    $logs[] = "[Flow] Processing total batch of " . count($items) . " items.";

    foreach ($items as $item) {
        $subscriberId = $item['subscriber_id'];
        $flowId = $item['flow_id'];
        $flowName = $item['flow_name'];
        $queueId = $item['queue_id'];
        $flowSteps = json_decode($item['flow_steps'], true);
        $fConfig = json_decode($item['flow_config'], true) ?: [];
        
        $currentStepId = $item['step_id'];
        $stepsProcessedInRun = 0;
        $MAX_STEPS = 10; // Safety limit per run
        $shouldContinue = true;

        $logs[] = "[Flow {$flowId}] Starting chain for Subscriber {$subscriberId} (Queue ID: {$queueId})";

        while ($shouldContinue && $stepsProcessedInRun < $MAX_STEPS) {
            $stepsProcessedInRun++;
            $currentStep = null;
            foreach ($flowSteps as $s) if ($s['id'] === $currentStepId) $currentStep = $s;

            if (!$currentStep) {
                $pdo->prepare("UPDATE subscriber_flow_states SET status = 'completed', updated_at = NOW() WHERE id = ?")->execute([$queueId]);
                $logs[] = "  -> Step '{$currentStepId}' not found. Flow completed for Subscriber {$subscriberId}.";
                $shouldContinue = false;
                break;
            }

            // --- CHECK EXIT CONDITIONS ---
            // 1. Inactive Subscriber
            if ($item['sub_status'] !== 'active') {
                $pdo->prepare("UPDATE subscriber_flow_states SET status = 'completed', updated_at = NOW() WHERE id = ?")->execute([$queueId]);
                logActivity($pdo, $subscriberId, 'exit_flow', $flowId, $flowName, 'Exited: Subscriber inactive/unsubscribed', $flowId); // FIX: Improve details
                $logs[] = "  -> Subscriber {$subscriberId} exited flow due to inactive status.";
                $shouldContinue = false; break;
            }
            
            // 2. Custom Exit Conditions (Purchased, Bounced, Replied, Segment Match)
            $flowExitConditions = $fConfig['exitConditions'] ?? [];
            if (!empty($flowExitConditions)) {
                // Check for segment match (if trigger was segment-based, and exit condition is to exit if no longer matching)
                $triggerStep = null;
                foreach($flowSteps as $s) if($s['type'] === 'trigger') $triggerStep = $s;
                if ($triggerStep && $triggerStep['config']['type'] === 'segment' && in_array('segment_no_match', $flowExitConditions)) {
                     $stmtSeg = $pdo->prepare("SELECT criteria FROM segments WHERE id = ?"); 
                     $stmtSeg->execute([$triggerStep['config']['targetId']]);
                     $segDef = $stmtSeg->fetch();
                     if ($segDef && !isSubscriberMatch($item, $segDef['criteria'])) {
                        $pdo->prepare("UPDATE subscriber_flow_states SET status = 'completed', updated_at = NOW() WHERE id = ?")->execute([$queueId]);
                        logActivity($pdo, $subscriberId, 'exit_flow', $flowId, $flowName, 'Exited: No longer matches original segment criteria', $flowId); // FIX: Improve details
                        $logs[] = "  -> Subscriber {$subscriberId} exited (no longer matches original segment).";
                        $shouldContinue = false; break;
                     }
                }

                $stmtExitCheck = $pdo->prepare("SELECT type, details FROM subscriber_activity WHERE subscriber_id = ? AND created_at >= ? ORDER BY created_at DESC LIMIT 1");
                $stmtExitCheck->execute([$subscriberId, $item['queue_created_at']]); 
                $lastActivity = $stmtExitCheck->fetch();

                if ($lastActivity) {
                    if (in_array('purchased', $flowExitConditions) && $lastActivity['type'] === 'purchase') {
                        $pdo->prepare("UPDATE subscriber_flow_states SET status = 'completed', updated_at = NOW() WHERE id = ?")->execute([$queueId]);
                        logActivity($pdo, $subscriberId, 'exit_flow', $flowId, $flowName, 'Exited: Customer made a purchase', $flowId); // FIX: Improve details
                        $logs[] = "  -> Subscriber {$subscriberId} exited (purchased).";
                        continue; // Fix: use continue
                    }
                    if (in_array('replied', $flowExitConditions) && $lastActivity['type'] === 'reply_email') {
                        $pdo->prepare("UPDATE subscriber_flow_states SET status = 'completed', updated_at = NOW() WHERE id = ?")->execute([$queueId]);
                        logActivity($pdo, $subscriberId, 'exit_flow', $flowId, $flowName, 'Exited: Customer replied to an email', $flowId); // FIX: Improve details
                        $logs[] = "  -> Subscriber {$subscriberId} exited (replied).";
                        continue; // Fix: use continue
                    }
                }
                if (in_array('bounced', $flowExitConditions)) {
                    $stmtBounceCheck = $pdo->prepare("SELECT id FROM mail_delivery_logs WHERE recipient = ? AND status = 'failed' AND sent_at >= ? LIMIT 1");
                    $stmtBounceCheck->execute([$item['sub_email'], $item['queue_created_at']]);
                    if ($stmtBounceCheck->fetch()) {
                        $pdo->prepare("UPDATE subscriber_flow_states SET status = 'completed', updated_at = NOW() WHERE id = ?")->execute([$queueId]);
                        logActivity($pdo, $subscriberId, 'exit_flow', $flowId, $flowName, 'Exited: Email delivery failed (bounced)', $flowId); // FIX: Improve details
                        $logs[] = "  -> Subscriber {$subscriberId} exited (bounced).";
                        continue; // Fix: use continue
                    }
                }
            }


            // --- RÀNG BUỘC THỜI GIAN & TẦN SUẤT ---
            // Áp dụng CÁC RÀNG BUỘC NÀY CHỈ KHI KHÔNG PHẢI LÀ CHUỖI ƯU TIÊN VÀ LÀ BƯỚC HÀNH ĐỘNG
            if ($currentStep['type'] === 'action' && !$isPriorityChain) {
                // [TIME CONSTRAINT] - Kiểm tra ngày/giờ kích hoạt
                $activeDays = $fConfig['activeDays'] ?? [0,1,2,3,4,5,6]; 
                $flowStartTime = $fConfig['startTime'] ?? '00:00';
                $flowEndTime = $fConfig['endTime'] ?? '23:59';
                
                if (!in_array($currentDayIdx, $activeDays) || $currentTime < $flowStartTime || $currentTime > $flowEndTime) {
                    $resched = date('Y-m-d H:i:s', strtotime('+1 hour')); 
                    $pdo->prepare("UPDATE subscriber_flow_states SET status = 'waiting', scheduled_at = ?, step_id = ?, updated_at = NOW() WHERE id = ?")
                        ->execute([$resched, $currentStepId, $queueId]);
                    $logs[] = "  -> Step '{$currentStep['label']}' rescheduled due to time/day constraints.";
                    $shouldContinue = false; break; // Dừng xử lý cho item này
                }

                // [FREQUENCY CAP] - Kiểm tra giới hạn tần suất gửi
                $cap = (int)($fConfig['frequencyCap'] ?? 0); 
                if ($cap > 0) {
                    $stmtCap = $pdo->prepare("SELECT COUNT(*) FROM mail_delivery_logs WHERE recipient = ? AND sent_at > DATE_SUB(NOW(), INTERVAL 24 HOUR)");
                    $stmtCap->execute([$item['sub_email']]);
                    if ($stmtCap->fetchColumn() >= $cap) { 
                        $resched = date('Y-m-d H:i:s', strtotime('+1 hour'));
                        $pdo->prepare("UPDATE subscriber_flow_states SET status = 'waiting', scheduled_at = ?, step_id = ?, updated_at = NOW() WHERE id = ?")
                            ->execute([$resched, $currentStepId, $queueId]);
                        $logs[] = "  -> Step '{$currentStep['label']}' rescheduled due to frequency cap.";
                        $shouldContinue = false; break; // Dừng xử lý cho item này
                    } 
                }
            } else if ($currentStep['type'] === 'action' && $isPriorityChain) {
                $logs[] = "  -> Step '{$currentStep['label']}' time/day and frequency cap constraints BYPASSED (Priority Chain).";
            }

            $nextStepId = null; 
            $nextScheduledAt = $now; 
            $isInstantStep = false; 

            $logs[] = "  -> Executing Step '{$currentStep['label']}' ({$currentStep['type']}).";
            switch ($currentStep['type']) {
                case 'action':
                    $config = $currentStep['config'];
                    $contextData = []; 
                    $htmlContent = resolveEmailContent($pdo, $config['templateId'] ?? '', $config['customHtml'] ?? '', $config['contentBody'] ?? '', $contextData);
                    
                    $subscriberData = [
                        'email' => $item['sub_email'], 'first_name' => $item['first_name'], 'last_name' => $item['last_name'], 'phone_number' => $item['phone_number'], 'company_name' => $item['company_name'], 'job_title' => $item['job_title'], 'date_of_birth' => $item['date_of_birth'], 'anniversary_date' => $item['anniversary_date']
                    ];
                    $finalHtml = replaceMergeTags($htmlContent, $subscriberData, $contextData);
                    $finalSubject = replaceMergeTags($config['subject'] ?? '', $subscriberData, $contextData);

                    $attachments = [];
                    $emailAttachments = json_decode($config['attachments'] ?? '[]', true); 
                    if (!empty($emailAttachments)) {
                        foreach ($emailAttachments as $att) {
                            if ($att['logic'] === 'all') {
                                $attachments[] = ['path' => $att['path'], 'name' => $att['name']];
                            } else if ($att['logic'] === 'match_email') {
                                if (strpos(strtolower($att['name']), strtolower($item['sub_email'])) !== false) {
                                    $attachments[] = ['path' => $att['path'], 'name' => $att['name']];
                                }
                            }
                        }
                    }

                    $res = $mailer->send($item['sub_email'], $finalSubject, $finalHtml, $subscriberId, null, $flowId, $flowName, $attachments);
                    
                    if ($res === true) {
                        $pdo->prepare("UPDATE flows SET stat_total_sent = stat_total_sent + 1 WHERE id = ?")->execute([$flowId]);
                        $pdo->prepare("UPDATE subscribers SET stats_sent = stats_sent + 1 WHERE id = ?")->execute([$subscriberId]);
                        logActivity($pdo, $subscriberId, 'receive_email', $flowId, $flowName, "Email sent: " . $currentStep['label'], $flowId); // FIX: Improve details
                        $logs[] = "  -> Email sent for {$item['sub_email']} for step '{$currentStep['label']}'.";
                    } else {
                         $logs[] = "  -> Failed to send email for {$item['sub_email']} for step '{$currentStep['label']}': " . (is_string($res) ? $res : 'Unknown Error');
                    }
                    $nextStepId = $currentStep['nextStepId'] ?? null;
                    $isInstantStep = true; 
                    break;

                case 'wait':
                    $dur = (int)($currentStep['config']['duration'] ?? 1);
                    $unit = $currentStep['config']['unit'] ?? 'hours';
                    $dt = new DateTime($now); $dt->modify("+$dur $unit");
                    $nextScheduledAt = $dt->format('Y-m-d H:i:s');
                    $nextStepId = $currentStep['nextStepId'] ?? null;
                    
                    $pdo->prepare("UPDATE subscriber_flow_states SET status = 'waiting', scheduled_at = ?, step_id = ?, updated_at = NOW() WHERE id = ?")
                        ->execute([$nextScheduledAt, $nextStepId, $queueId]);
                    
                    $logs[] = "  -> Step '{$currentStep['label']}' is WAIT. Pausing chain. Next scheduled for {$nextScheduledAt}.";
                    $shouldContinue = false; 
                    break;
                
                case 'condition':
                    $condType = $currentStep['config']['conditionType'] ?? 'opened';
                    $waitDur = (int)($currentStep['config']['waitDuration'] ?? 1); 
                    $waitUnit = $currentStep['config']['waitUnit'] ?? 'hours';
                    
                    $timeout = new DateTime($item['queue_created_at']); 
                    $timeout->modify("+$waitDur $waitUnit");
                    $isTimedOut = new DateTime($now) > $timeout;

                    $isMatched = false;
                    
                    if ($condType === 'clicked') {
                        $linkTargets = $currentStep['config']['linkTargets'] ?? [];
                        if (!is_array($linkTargets) && !empty($currentStep['config']['linkTarget'])) {
                            $linkTargets = [$currentStep['config']['linkTarget']];
                        }
                        
                        $stmtAct = $pdo->prepare("SELECT details FROM subscriber_activity WHERE subscriber_id = ? AND reference_id = ? AND type = 'click_link' AND created_at >= ?");
                        $stmtAct->execute([$subscriberId, $flowId, $item['queue_created_at']]);
                        $clicks = $stmtAct->fetchAll(PDO::FETCH_COLUMN);
                        
                        if (count($clicks) > 0) {
                            if (empty($linkTargets)) {
                                $isMatched = true; 
                                $logs[] = "  -> Subscriber {$subscriberId} clicked ANY link for step '{$currentStep['label']}'.";
                            } else {
                                foreach ($clicks as $detail) {
                                    $url = str_replace("Click link: ", "", $detail); 
                                    if (in_array($url, $linkTargets)) {
                                        $isMatched = true;
                                        $logs[] = "  -> Subscriber {$subscriberId} clicked targeted link '{$url}' for step '{$currentStep['label']}'.";
                                        break;
                                    }
                                }
                            }
                        }
                    } else {
                        $actType = '';
                        if ($condType === 'replied') $actType = 'reply_email';
                        else if ($condType === 'unsubscribed') $actType = 'unsubscribe';
                        else if ($condType === 'opened') $actType = 'open_email';
                        else if ($condType === 'delivered') $actType = 'receive_email';
                        
                        if (!empty($actType)) {
                            $stmtAct = $pdo->prepare("SELECT id FROM subscriber_activity WHERE subscriber_id = ? AND reference_id = ? AND type = ? AND created_at >= ? LIMIT 1");
                            $stmtAct->execute([$subscriberId, $flowId, $actType, $item['queue_created_at']]);
                            if ($stmtAct->fetch()) {
                                $isMatched = true;
                                $logs[] = "  -> Subscriber {$subscriberId} performed '{$actType}' for step '{$currentStep['label']}'.";
                            }
                        }
                    }

                    if ($isMatched) {
                        $nextStepId = $currentStep['yesStepId'] ?? null;
                        $logs[] = "  -> Subscriber {$subscriberId} for step '{$currentStep['label']}' matched condition. Moving to 'YES' path.";
                    } elseif ($isTimedOut) {
                        $nextStepId = $currentStep['noStepId'] ?? null;
                        $logs[] = "  -> Subscriber {$subscriberId} for step '{$currentStep['label']}' timed out. Moving to 'NO' path.";
                    } else {
                        $nextScheduledAt = date('Y-m-d H:i:s', strtotime('+5 minutes')); 
                        $pdo->prepare("UPDATE subscriber_flow_states SET status = 'waiting', scheduled_at = ?, step_id = ?, updated_at = NOW() WHERE id = ?")
                            ->execute([$nextScheduledAt, $currentStepId, $queueId]);
                        $logs[] = "  -> Step '{$currentStep['label']}' still waiting for condition. Rescheduled for {$nextScheduledAt}.";
                        $shouldContinue = false; break;
                    }
                    $isInstantStep = true;
                    break;

                case 'update_tag':
                    $existingTags = json_decode($item['sub_tags'] ?? '[]', true); 
                    $tagsToApply = $currentStep['config']['tags'] ?? [];
                    $action = $currentStep['config']['action'] ?? 'add';
                    
                    $newTags = [];
                    if ($action === 'remove') {
                        $newTags = array_values(array_diff($existingTags, $tagsToApply)); 
                    } else { 
                        $newTags = array_unique(array_merge($existingTags, $tagsToApply));
                    }
                        
                    $pdo->prepare("UPDATE subscribers SET tags = ? WHERE id = ?")->execute([json_encode($newTags), $subscriberId]);
                    $item['sub_tags'] = json_encode($newTags); 
                    $nextStepId = $currentStep['nextStepId'] ?? null;
                    $isInstantStep = true;
                    break;

                case 'list_action':
                    $lid = (string)($currentStep['config']['listId'] ?? ''); // Ensure listId is string
                    $lAction = $currentStep['config']['action'] ?? 'add';
                    if ($lid) {
                        if ($lAction === 'add') {
                            $pdo->prepare("INSERT IGNORE INTO subscriber_lists (subscriber_id, list_id) VALUES (?, ?)")->execute([$subscriberId, $lid]);
                            $pdo->prepare("UPDATE lists SET subscriber_count = (SELECT COUNT(*) FROM subscriber_lists WHERE list_id = ?) WHERE id = ?")
                                 ->execute([$lid, $lid]); // Recalculate count
                        } else { 
                            $pdo->prepare("DELETE FROM subscriber_lists WHERE subscriber_id = ? AND list_id = ?")->execute([$subscriberId, $lid]);
                            $pdo->prepare("UPDATE lists SET subscriber_count = GREATEST(0, (SELECT COUNT(*) FROM subscriber_lists WHERE list_id = ?)) WHERE id = ?")
                                 ->execute([$lid, $lid]); // Recalculate count, ensuring it's not negative
                        }
                        logActivity($pdo, $subscriberId, 'list_action', $lid, 'List Action', "Action: $lAction on list " . ($lid ? "List ID $lid" : "Unknown"), $flowId); // FIX: Pass flow_id, add list ID to details
                        $logs[] = "  -> Subscriber {$subscriberId}: {$lAction} from list '{$lid}' for step '{$currentStep['label']}'.";
                    }
                    $nextStepId = $currentStep['nextStepId'] ?? null;
                    $isInstantStep = true;
                    break;

                case 'split_test':
                    $ratioA = (int)($currentStep['config']['ratioA'] ?? 50);
                    $nextStepId = (rand(1, 100) <= $ratioA) ? ($currentStep['pathAStepId'] ?? null) : ($currentStep['pathBStepId'] ?? null); 
                    $logs[] = "  -> Subscriber {$subscriberId}: Split test for step '{$currentStep['label']}' - picked path " . (rand(1,100) <= $ratioA ? 'A' : 'B') . ".";
                    $isInstantStep = true;
                    break;
                
                case 'link_flow':
                    if (!empty($currentStep['config']['linkedFlowId'])) {
                        $pastTime = date('Y-m-d H:i:s', strtotime('-1 second')); 
                        $pdo->prepare("INSERT INTO subscriber_flow_states (subscriber_id, flow_id, step_id, scheduled_at, status, created_at, updated_at) VALUES (?, ?, ?, ?, 'waiting', NOW(), NOW())")
                            ->execute([$subscriberId, (string)$currentStep['config']['linkedFlowId'], 'trigger', $pastTime]); // Ensure linkedFlowId is string
                        
                        // Get linked flow name for details
                        $stmtLinkedFlowName = $pdo->prepare("SELECT name FROM flows WHERE id = ?");
                        $stmtLinkedFlowName->execute([$currentStep['config']['linkedFlowId']]);
                        $linkedFlowName = $stmtLinkedFlowName->fetchColumn();

                        logActivity($pdo, $subscriberId, 'enter_flow', $currentStep['config']['linkedFlowId'], 'Linked Flow', "Linked from {$flowName} to Flow: " . ($linkedFlowName ?: $currentStep['config']['linkedFlowId']), $currentStep['config']['linkedFlowId']); // FIX: Pass flow_id of linked flow, improve details
                        $logs[] = "  -> Subscriber {$subscriberId}: Linked to flow '{$currentStep['config']['linkedFlowId']}' from step '{$currentStep['label']}'.";
                    }
                    $pdo->prepare("UPDATE subscriber_flow_states SET status = 'completed', updated_at = NOW() WHERE id = ?")->execute([$queueId]);
                    $logs[] = "  -> Flow {$flowId} completed for Subscriber {$subscriberId} due to link_flow.";
                    $shouldContinue = false; 
                    break;

                case 'remove_action':
                    if ($currentStep['config']['actionType'] === 'unsubscribe') {
                        $pdo->prepare("UPDATE subscribers SET status = 'unsubscribed' WHERE id = ?")->execute([$subscriberId]);
                        logActivity($pdo, $subscriberId, 'unsubscribe', $flowId, $flowName, 'Unsubscribed via flow', $flowId); // FIX: Pass flow_id
                        $logs[] = "  -> Subscriber {$subscriberId}: Unsubscribed via step '{$currentStep['label']}'.";
                    }
                    else if ($currentStep['config']['actionType'] === 'delete_contact') {
                        // Reduce list counts first
                        $stmtLists = $pdo->prepare("SELECT list_id FROM subscriber_lists WHERE subscriber_id = ?");
                        $stmtLists->execute([$subscriberId]);
                        $listIds = $stmtLists->fetchAll(PDO::FETCH_COLUMN);
                        foreach($listIds as $lid) {
                            $pdo->prepare("UPDATE lists SET subscriber_count = GREATEST(0, (SELECT COUNT(*) FROM subscriber_lists WHERE list_id = ?)) WHERE id = ?")
                                 ->execute([$lid, $lid]); // Recalculate count, ensuring it's not negative
                        }
                        $pdo->prepare("DELETE FROM subscribers WHERE id = ?")->execute([$subscriberId]);
                        logActivity($pdo, $subscriberId, 'delete_contact', $flowId, $flowName, 'Deleted via flow', $flowId); // FIX: Pass flow_id
                        $logs[] = "  -> Subscriber {$subscriberId}: Deleted via step '{$currentStep['label']}'.";
                    }
                    $pdo->prepare("UPDATE subscriber_flow_states SET status = 'completed', updated_at = NOW() WHERE id = ?")->execute([$queueId]);
                    $logs[] = "  -> Flow {$flowId} completed for Subscriber {$subscriberId} due to remove_action.";
                    $shouldContinue = false;
                    break;

                default: 
                    $nextStepId = $currentStep['nextStepId'] ?? null; 
                    $logs[] = "  -> Executed unknown step type '{$currentStep['type']}' for '{$currentStep['label']}'.";
                    $isInstantStep = true;
                    break;
            }

            if ($shouldContinue) {
                if ($nextStepId) {
                    if ($isInstantStep) {
                        $currentStepId = $nextStepId;
                        $logs[] = "  -> Step finished. Chaining to next step: $currentStepId";
                        // No DB update here, status remains 'processing' for fast-chaining within this worker run.
                    } else {
                        // This branch is hit by 'wait' or 'condition' if they scheduled for future and set shouldContinue=false
                        // DB update for 'waiting' state already handled inside 'wait'/'condition' blocks.
                        $shouldContinue = false; 
                    }
                } else { // No nextStepId, flow completed
                    $pdo->prepare("UPDATE subscriber_flow_states SET status = 'completed', updated_at = NOW() WHERE id = ?")->execute([$queueId]);
                    $pdo->prepare("UPDATE flows SET stat_completed = stat_completed + 1 WHERE id = ?")->execute([$flowId]);
                    logActivity($pdo, $subscriberId, 'complete_flow', $flowId, $flowName, 'Flow finished successfully', $flowId); // FIX: Improve details
                    $logs[] = "  -> End of flow reached. Flow completed for Subscriber {$subscriberId}.";
                    $shouldContinue = false;
                }
            }
        } // End of while ($shouldContinue && $stepsProcessedInRun < $MAX_STEPS)
}
    $pdo->commit(); // Final commit for the global transaction if everything succeeds

} catch (Exception $e) { // *** GLOBAL CATCH BLOCK ***
    if ($pdo->inTransaction()) {
        $pdo->rollBack(); // Rollback global transaction if any exception
    }
    $logs[] = "[ERROR] An exception occurred: " . $e->getMessage() . " on line " . $e->getLine() . " in " . $e->getFile();
} finally { // *** GLOBAL FINALLY BLOCK ***
    // Ensure cleanup of any remaining open transactions, especially from early exits
    // that might bypass the main `pdo->commit()` but are still within the global transaction scope.
    if ($pdo->inTransaction()) {
        $pdo->rollBack();
        $logs[] = "[WARNING] Transaction was rolled back in finally block.";
    }
}

// Add log to file for debugging
file_put_contents(__DIR__ . '/worker_flow.log', implode("\n", $logs) . "\n", FILE_APPEND);
echo implode("\n", $logs);
?>