
import React, { useState, useEffect, useCallback } from 'react';
import { EmailBlock, EmailBlockType, EmailBodyStyle, EmailBlockStyle, ListItem, Template } from '../../../types';
import EmailTopBar from './EmailTopBar';
import EmailToolbox from './EmailToolbox';
import EmailCanvas from './EmailCanvas';
import EmailProperties from './EmailProperties';
import Toast, { ToastType } from '../../common/Toast';
import Modal from '../../common/Modal';
import Input from '../../common/Input';
import Button from '../../common/Button';
import { Box, Save } from 'lucide-react';

interface EmailEditorProps {
  template?: Template;
  onSave: (data: Partial<Template>) => void;
  onCancel: () => void;
}

const DEFAULT_BODY_STYLE: EmailBodyStyle = {
    backgroundColor: '#F3F4F6',
    contentBackgroundColor: '#FFFFFF',
    contentWidth: '600px',
    fontFamily: 'Arial, sans-serif',
    linkColor: '#2563eb' 
};

const DEFAULT_BLOCKS: EmailBlock[] = []; 

export const SOCIAL_COLORS_COMPILE: Record<string, string> = {
    facebook: '#1877F2', twitter: '#1DA1F2', instagram: '#E4405F',
    linkedin: '#0A66C2', youtube: '#FF0000', website: '#333333',
    email: '#EA4335', phone: '#34A853', tiktok: '#000000', github: '#181717', address: '#666666', custom: '#999999'
};

// --- COMPILER CORE ---
export const compileHTML = (blocks: EmailBlock[], bodyStyle: EmailBodyStyle, title: string) => {
    
    // HEAD CSS: Reset + Responsive + Client Fixes
    const HEAD_CSS = `
    <style>
        html, body { margin: 0 auto !important; padding: 0 !important; height: 100% !important; width: 100% !important; font-family: ${bodyStyle.fontFamily}; background-color: ${bodyStyle.backgroundColor}; }
        * { -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; }
        div[style*="margin: 16px 0"] { margin: 0 !important; }
        table, td { mso-table-lspace: 0pt !important; mso-table-rspace: 0pt !important; }
        table { border-spacing: 0 !important; border-collapse: collapse !important; table-layout: fixed !important; margin: 0 auto !important; }
        img { -ms-interpolation-mode: bicubic; }
        a { text-decoration: none; color: ${bodyStyle.linkColor} !important; }
        
        /* RESPONSIVE STYLES */
        @media only screen and (max-width: 600px) {
            .email-container { width: 100% !important; max-width: 100% !important; }
            .stack-column, .stack-column-center { display: block !important; width: 100% !important; max-width: 100% !important; direction: ltr !important; }
            .stack-column-center { text-align: center !important; }
            .fluid-img { width: 100% !important; max-width: 100% !important; height: auto !important; }
            .mobile-hide { display: none !important; }
            .mobile-center { text-align: center !important; }
            .mobile-padding { padding-left: 20px !important; padding-right: 20px !important; }
            
            /* DYNAMIC CLASSES GENERATED BY BLOCKS */
            .mobile-w-full { width: 100% !important; }
        }
    </style>
    <!--[if mso]>
    <xml>
      <o:OfficeDocumentSettings>
        <o:AllowPNG/>
        <o:PixelsPerInch>96</o:PixelsPerInch>
      </o:OfficeDocumentSettings>
    </xml>
    <![endif]-->
    `;

    // Helper: Convert style object to inline CSS string
    const getStyleStr = (s: EmailBlockStyle): string => {
        let css = '';
        if (s.backgroundColor) css += `background-color: ${s.backgroundColor}; `;
        if (s.color) css += `color: ${s.color}; `;
        if (s.fontFamily) css += `font-family: ${s.fontFamily}; `;
        if (s.fontSize) css += `font-size: ${s.fontSize}; `;
        if (s.fontWeight) css += `font-weight: ${s.fontWeight}; `;
        if (s.fontStyle) css += `font-style: ${s.fontStyle}; `;
        if (s.textAlign) css += `text-align: ${s.textAlign}; `;
        if (s.lineHeight) css += `line-height: ${s.lineHeight}; `;
        if (s.letterSpacing) css += `letter-spacing: ${s.letterSpacing}; `;
        if (s.textDecoration) css += `text-decoration: ${s.textDecoration}; `;
        if (s.textTransform) css += `text-transform: ${s.textTransform}; `;
        
        // Spacing
        if (s.paddingTop) css += `padding-top: ${s.paddingTop}; `;
        if (s.paddingRight) css += `padding-right: ${s.paddingRight}; `;
        if (s.paddingBottom) css += `padding-bottom: ${s.paddingBottom}; `;
        if (s.paddingLeft) css += `padding-left: ${s.paddingLeft}; `;
        
        // Borders
        const bs = s.borderStyle || 'solid';
        const bc = s.borderColor || '#ddd';
        if (s.borderTopWidth && s.borderTopWidth !== '0px') css += `border-top: ${s.borderTopWidth} ${bs} ${bc}; `;
        if (s.borderBottomWidth && s.borderBottomWidth !== '0px') css += `border-bottom: ${s.borderBottomWidth} ${bs} ${bc}; `;
        if (s.borderLeftWidth && s.borderLeftWidth !== '0px') css += `border-left: ${s.borderLeftWidth} ${bs} ${bc}; `;
        if (s.borderRightWidth && s.borderRightWidth !== '0px') css += `border-right: ${s.borderRightWidth} ${bs} ${bc}; `;
        if (s.borderRadius) css += `border-radius: ${s.borderRadius}; `;

        return css;
    };

    const getBgAttribute = (s: EmailBlockStyle) => {
        return s.backgroundColor ? `bgcolor="${s.backgroundColor}"` : '';
    };

    // --- RECURSIVE RENDERER ---
    const renderBlock = (b: EmailBlock): string => {
        const s = b.style || {};
        const contentWidthPx = parseFloat(bodyStyle.contentWidth.replace('px', ''));

        // 1. SECTION (Full Width Wrapper)
        if (b.type === 'section') {
            const bgImg = s.backgroundImage?.replace(/url\(['"]?(.*?)['"]?\)/, '$1');
            const vmlStart = bgImg ? `
                <!--[if gte mso 9]>
                <v:rect xmlns:v="urn:schemas-microsoft-com:vml" fill="true" stroke="false" style="width:${contentWidthPx}px;height:100%;">
                <v:fill type="tile" src="${bgImg}" color="${s.backgroundColor || 'transparent'}" />
                <v:textbox inset="0,0,0,0">
                <![endif]-->
            ` : '';
            const vmlEnd = bgImg ? `
                <!--[if gte mso 9]>
                </v:textbox>
                </v:rect>
                <![endif]-->
            ` : '';

            // CSS Background for non-Outlook
            const bgStyle = bgImg 
                ? `background-image: url('${bgImg}'); background-size: ${s.backgroundSize || 'cover'}; background-position: ${s.backgroundPosition || 'center'}; background-repeat: ${s.backgroundRepeat || 'no-repeat'};` 
                : '';

            return `
            <!-- SECTION START -->
            <table border="0" cellpadding="0" cellspacing="0" width="100%" style="table-layout: fixed; ${getStyleStr(s)} ${bgStyle}" ${getBgAttribute(s)}>
                <tr>
                    <td align="center" valign="top">
                        ${vmlStart}
                        <table border="0" cellpadding="0" cellspacing="0" width="100%" style="max-width: ${bodyStyle.contentWidth};" class="email-container">
                            <tr>
                                <td align="center" valign="top" style="padding-top: ${s.paddingTop}; padding-bottom: ${s.paddingBottom};">
                                    <table border="0" cellpadding="0" cellspacing="0" width="100%" ${s.contentBackgroundColor ? `bgcolor="${s.contentBackgroundColor}"` : ''} style="${s.contentBackgroundColor ? `background-color: ${s.contentBackgroundColor};` : ''} border-radius: ${s.borderRadius || '0px'};">
                                        ${b.children?.map(renderBlock).join('')}
                                    </table>
                                </td>
                            </tr>
                        </table>
                        ${vmlEnd}
                    </td>
                </tr>
            </table>
            <!-- SECTION END -->
            `;
        }

        // 2. ROW (Column Wrapper)
        if (b.type === 'row') {
            const cols = b.children || [];
            
            // Logic for MSO columns (Ghost Tables)
            let colHTML = '';
            
            // Start MSO Container
            colHTML += `<!--[if mso]><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><![endif]-->`;

            cols.forEach((col) => {
                const w = col.style.width || '100%';
                const wPx = Math.floor((parseFloat(w) / 100) * contentWidthPx);
                
                // MSO Column
                colHTML += `<!--[if mso]><td valign="${col.style.verticalAlign || 'top'}" width="${wPx}"><![endif]-->`;
                
                // Real Column (Div for stacking)
                colHTML += `
                <div class="stack-column" style="display: inline-block; width: 100%; max-width: ${w}; vertical-align: ${col.style.verticalAlign || 'top'};">
                    <table border="0" cellpadding="0" cellspacing="0" width="100%" style="border-collapse: separate;">
                        <tr>
                            <td valign="${col.style.verticalAlign || 'top'}" style="${getStyleStr(col.style)}" ${getBgAttribute(col.style)}>
                                ${col.children?.map(renderBlock).join('') || '&nbsp;'}
                            </td>
                        </tr>
                    </table>
                </div>`;
                
                // End MSO Column
                colHTML += `<!--[if mso]></td><![endif]-->`;
            });

            // End MSO Container
            colHTML += `<!--[if mso]></tr></table><![endif]-->`;

            return `
            <tr>
                <td style="padding: ${s.paddingTop || '0'} ${s.paddingRight || '0'} ${s.paddingBottom || '0'} ${s.paddingLeft || '0'}; font-size: 0; text-align: center; ${getStyleStr(s)}">
                    ${colHTML}
                </td>
            </tr>
            `;
        }

        // 3. CONTENT BLOCKS
        // Text
        if (b.type === 'text') {
            return `
            <table border="0" cellpadding="0" cellspacing="0" width="100%">
                <tr>
                    <td style="${getStyleStr(s)} color: ${s.color}; font-family: ${s.fontFamily || bodyStyle.fontFamily}; font-size: ${s.fontSize}; line-height: ${s.lineHeight}; text-align: ${s.textAlign};">
                        ${b.content}
                    </td>
                </tr>
            </table>`;
        }

        // Button (VML Bulletproof)
        if (b.type === 'button') {
            const btnBg = s.contentBackgroundColor || s.backgroundColor || '#2563eb';
            const btnColor = s.color || '#ffffff';
            const btnRadius = parseInt(s.borderRadius || '4');
            const align = s.textAlign || 'center';
            const width = s.width === '100%' ? '100%' : 'auto';
            const widthStyle = s.width === '100%' ? 'display: block; width: 100%;' : 'display: inline-block;';

            return `
            <table border="0" cellpadding="0" cellspacing="0" width="100%">
                <tr>
                    <td align="${align}" style="padding: ${s.paddingTop || '10px'} ${s.paddingRight || '0'} ${s.paddingBottom || '10px'} ${s.paddingLeft || '0'};">
                        <!--[if mso]>
                        <v:roundrect xmlns:v="urn:schemas-microsoft-com:vml" xmlns:w="urn:schemas-microsoft-com:office:word" href="${b.url}" style="height:40px;v-text-anchor:middle;width:${s.width === '100%' ? contentWidthPx : '200'}px;" arcsize="${Math.round(btnRadius*2)}%" stroke="f" fillcolor="${btnBg}">
                        <w:anchorlock/>
                        <center>
                        <![endif]-->
                        <a href="${b.url}" style="background-color:${btnBg}; border-radius:${s.borderRadius}; color:${btnColor}; font-family:${s.fontFamily || bodyStyle.fontFamily}; font-size:${s.fontSize}; font-weight:${s.fontWeight}; line-height:40px; text-align:center; text-decoration:none; width:${width}; -webkit-text-size-adjust:none; ${widthStyle} padding: 10px 20px;">
                            ${b.content}
                        </a>
                        <!--[if mso]>
                        </center>
                        </v:roundrect>
                        <![endif]-->
                    </td>
                </tr>
            </table>`;
        }

        // Image
        if (b.type === 'image') {
            return `
            <table border="0" cellpadding="0" cellspacing="0" width="100%">
                <tr>
                    <td align="${s.textAlign || 'center'}" style="padding: ${s.paddingTop || '0'} ${s.paddingRight || '0'} ${s.paddingBottom || '0'} ${s.paddingLeft || '0'};">
                        <a href="${b.url || '#'}" target="_blank">
                            <img src="${b.content}" alt="${b.altText || ''}" width="${parseInt(s.width?.replace('%','') || '600')}" class="fluid-img" style="display: block; width: 100%; max-width: ${s.width}; height: auto; border: 0; border-radius: ${s.borderRadius};" />
                        </a>
                    </td>
                </tr>
            </table>`;
        }

        // Spacer
        if (b.type === 'spacer') {
            return `<table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td height="${parseInt(s.height || '20')}" style="font-size: 0; line-height: 0;">&nbsp;</td></tr></table>`;
        }

        // Divider
        if (b.type === 'divider') {
            return `
            <table border="0" cellpadding="0" cellspacing="0" width="100%">
                <tr>
                    <td style="padding: ${s.paddingTop || '10px'} ${s.paddingRight || '0'} ${s.paddingBottom || '10px'} ${s.paddingLeft || '0'};">
                        <div style="border-top: ${s.borderTopWidth || '1px'} ${s.borderStyle || 'solid'} ${s.borderColor || '#ddd'}; height: 1px; width: 100%;"></div>
                    </td>
                </tr>
            </table>`;
        }

        return '';
    };

    return `<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="x-apple-disable-message-reformatting">
    <title>${title}</title>
    ${HEAD_CSS}
</head>
<body width="100%" bgcolor="${bodyStyle.backgroundColor}" style="margin: 0; padding: 0 !important; mso-line-height-rule: exactly;">
    <center style="width: 100%; background-color: ${bodyStyle.backgroundColor};">
        <!--[if mso | IE]>
        <table role="presentation" border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="${bodyStyle.backgroundColor}">
        <tr>
        <td>
        <![endif]-->
        
        <div style="max-width: ${bodyStyle.contentWidth}; margin: 0 auto; background-color: ${bodyStyle.contentBackgroundColor}; box-shadow: 0 0 10px rgba(0,0,0,0.05);">
            ${blocks.map(renderBlock).join('')}
        </div>

        <!--[if mso | IE]>
        </td>
        </tr>
        </table>
        <![endif]-->
    </center>
</body>
</html>`;
};

// --- EDITOR CONTAINER ---
const EmailEditor: React.FC<EmailEditorProps> = ({ template, onSave, onCancel }) => {
  const [editorMode, setEditorMode] = useState<'visual' | 'code'>('visual');
  const [blocks, setBlocks] = useState<EmailBlock[]>(template?.blocks || DEFAULT_BLOCKS);
  const [bodyStyle, setBodyStyle] = useState<EmailBodyStyle>(template?.bodyStyle || DEFAULT_BODY_STYLE);
  const [name, setName] = useState(template?.name || 'Thiết kế mới');
  const [customHtml, setCustomHtml] = useState(template?.htmlContent || '');
  const [selectedBlockId, setSelectedBlockId] = useState<string | null>(null);
  const [viewMode, setViewMode] = useState<'desktop' | 'mobile'>('desktop');
  const [toast, setToast] = useState({ message: '', type: 'info' as ToastType, isVisible: false });
  const [history, setHistory] = useState<EmailBlock[][]>([template?.blocks || DEFAULT_BLOCKS]);
  const [historyIndex, setHistoryIndex] = useState(0);
  
  const [savedSections, setSavedSections] = useState<{id: string, name: string, data: EmailBlock}[]>([]);
  const [saveSectionModal, setSaveSectionModal] = useState<{ isOpen: boolean, block: EmailBlock | null, name: string }>({ isOpen: false, block: null, name: '' });

  // Load Saved Sections
  useEffect(() => {
      const saved = localStorage.getItem('mailflow_saved_sections');
      if (saved) {
          try { setSavedSections(JSON.parse(saved)); } catch (e) {}
      }
  }, []);

  // Sync HTML for Code View
  useEffect(() => {
      if (editorMode === 'visual') {
          setCustomHtml(compileHTML(blocks, bodyStyle, name));
      }
  }, [editorMode, blocks, bodyStyle, name]);

  const addToHistory = useCallback((newBlocks: EmailBlock[]) => {
      const newHistory = history.slice(0, historyIndex + 1);
      newHistory.push(newBlocks);
      if (newHistory.length > 50) newHistory.shift();
      setHistory(newHistory);
      setHistoryIndex(newHistory.length - 1);
      setBlocks(newBlocks);
  }, [history, historyIndex]);

  const handleUndo = useCallback(() => {
      if (historyIndex > 0) {
          const newIndex = historyIndex - 1;
          setHistoryIndex(newIndex);
          setBlocks(history[newIndex]);
          setSelectedBlockId(null); 
      }
  }, [history, historyIndex]);

  const handleRedo = useCallback(() => {
      if (historyIndex < history.length - 1) {
          const newIndex = historyIndex + 1;
          setHistoryIndex(newIndex);
          setBlocks(history[newIndex]);
      }
  }, [history, historyIndex]);

  const handleSaveData = () => {
      const finalHtml = editorMode === 'code' ? customHtml : compileHTML(blocks, bodyStyle, name);
      onSave({
          name,
          blocks: editorMode === 'visual' ? blocks : [],
          bodyStyle: editorMode === 'visual' ? bodyStyle : undefined,
          htmlContent: finalHtml,
          thumbnail: 'https://placehold.co/600x400/f1f5f9/94a3b8?text=' + (editorMode === 'code' ? 'HTML+Template' : 'Visual+Template')
      });
  };

  const updateBlocks = (newBlocks: EmailBlock[], pushToHistory: boolean = true) => {
      if (pushToHistory) {
          addToHistory(newBlocks);
      } else {
          setBlocks(newBlocks);
      }
  };

  const handleSaveSection = (block: EmailBlock) => {
      setSaveSectionModal({ isOpen: true, block, name: `Section ${savedSections.length + 1}` });
  };

  const confirmSaveSection = () => {
      if (saveSectionModal.block && saveSectionModal.name) {
          const newSaved = {
              id: crypto.randomUUID(),
              name: saveSectionModal.name,
              data: saveSectionModal.block
          };
          const updatedList = [newSaved, ...savedSections];
          setSavedSections(updatedList);
          localStorage.setItem('mailflow_saved_sections', JSON.stringify(updatedList));
          setToast({ message: 'Đã lưu section vào thư viện.', type: 'success', isVisible: true });
          setSaveSectionModal({ isOpen: false, block: null, name: '' });
      }
  };

  // Helper to find selected block deep
  const findBlock = (id: string, list: EmailBlock[]): EmailBlock | null => {
      for (const b of list) {
          if (b.id === id) return b;
          if (b.children) {
              const f = findBlock(id, b.children);
              if (f) return f;
          }
      }
      return null;
  };

  const selectedBlock = selectedBlockId ? findBlock(selectedBlockId, blocks) : null;

  return (
    <div className="fixed inset-0 z-[200] bg-[#eef2f6] flex flex-col animate-in fade-in duration-300 font-sans">
        <EmailTopBar 
            name={name} setName={setName} editorMode={editorMode} setEditorMode={setEditorMode}
            viewMode={viewMode} setViewMode={setViewMode} canUndo={historyIndex > 0} canRedo={historyIndex < history.length - 1}
            onUndo={handleUndo} onRedo={handleRedo} onSave={handleSaveData} onCancel={onCancel}
            onPreview={() => { const win = window.open(); win?.document.write(editorMode === 'code' ? customHtml : compileHTML(blocks, bodyStyle, name)); }}
        />
        <div className="flex-1 flex overflow-hidden">
            {editorMode === 'visual' && (
                <EmailToolbox 
                    blocks={blocks} 
                    selectedBlockId={selectedBlockId} 
                    onSelectBlock={setSelectedBlockId}
                    savedSections={savedSections}
                    onDragStart={(e, type, layout) => { 
                        if (type === 'saved' && layout) {
                            e.dataTransfer.setData('type', 'saved');
                            e.dataTransfer.setData('payload', layout);
                        } else {
                            e.dataTransfer.setData('type', type); 
                            if(layout) e.dataTransfer.setData('layout', layout); 
                        }
                        e.dataTransfer.effectAllowed = 'copyMove'; 
                    }} 
                />
            )}
            <EmailCanvas 
                mode={editorMode} 
                blocks={blocks} 
                bodyStyle={bodyStyle} 
                viewMode={viewMode} 
                customHtml={customHtml} 
                selectedBlockId={selectedBlockId} 
                onSelectBlock={setSelectedBlockId} 
                onUpdateBlocks={updateBlocks} 
                setCustomHtml={setCustomHtml}
                onSaveSection={handleSaveSection} 
            />
            {editorMode === 'visual' && (
                <EmailProperties 
                    selectedBlock={selectedBlock} 
                    bodyStyle={bodyStyle} 
                    deviceMode={viewMode}
                    blocks={blocks}
                    onUpdateBodyStyle={setBodyStyle}
                    onUpdateBlock={(id, data) => { 
                        // Deep update helper
                        const updateDeep = (list: EmailBlock[]): EmailBlock[] => { 
                            return list.map(b => { 
                                if(b.id === id) { 
                                    // Logic for Mobile Override
                                    if (data.style?.mobile) {
                                        return { ...b, ...data, style: { ...b.style, mobile: { ...b.style.mobile, ...data.style.mobile } } };
                                    }
                                    return { ...b, ...data, style: { ...b.style, ...(data.style || {}) } }; 
                                } 
                                if(b.children) return { ...b, children: updateDeep(b.children) }; 
                                return b; 
                            }); 
                        }; 
                        updateBlocks(updateDeep(blocks)); 
                    }}
                    onDeleteBlock={(id) => { 
                        const deleteDeep = (list: EmailBlock[]): EmailBlock[] => list.filter(b => b.id !== id).map(b => ({ ...b, children: b.children ? deleteDeep(b.children) : undefined })); 
                        updateBlocks(deleteDeep(blocks)); 
                        setSelectedBlockId(null); 
                    }}
                    onDuplicateBlock={(block) => { 
                        const duplicateDeep = (b: EmailBlock): EmailBlock => ({ ...b, id: crypto.randomUUID(), children: b.children?.map(duplicateDeep) }); 
                        // Simplified append logic for duplication
                        updateBlocks([...blocks, duplicateDeep(block)]); 
                        setSelectedBlockId(null); 
                    }}
                    onDeselect={() => setSelectedBlockId(null)}
                />
            )}
        </div>
        
        {saveSectionModal.isOpen && (
            <Modal
                isOpen={saveSectionModal.isOpen}
                onClose={() => setSaveSectionModal({ isOpen: false, block: null, name: '' })}
                title="Lưu Section mẫu"
                size="sm"
                footer={
                    <div className="flex justify-between w-full">
                        <Button variant="ghost" onClick={() => setSaveSectionModal({ isOpen: false, block: null, name: '' })}>Hủy</Button>
                        <Button onClick={confirmSaveSection} icon={Save} disabled={!saveSectionModal.name.trim()}>Lưu ngay</Button>
                    </div>
                }
            >
                <div className="space-y-6">
                    <div className="p-4 bg-indigo-50 border border-indigo-100 rounded-2xl flex gap-4 items-center">
                        <div className="p-3 bg-white rounded-2xl shadow-sm text-indigo-600">
                            <Box className="w-6 h-6" />
                        </div>
                        <div>
                            <p className="text-sm font-bold text-indigo-900">Tái sử dụng</p>
                            <p className="text-[11px] text-indigo-700 leading-tight mt-0.5">Lưu block này để dùng lại cho các email khác.</p>
                        </div>
                    </div>
                    <Input 
                        label="Tên Section" 
                        placeholder="VD: Header Logo..." 
                        value={saveSectionModal.name} 
                        onChange={(e) => setSaveSectionModal({ ...saveSectionModal, name: e.target.value })} 
                        autoFocus
                    />
                </div>
            </Modal>
        )}

        <Toast message={toast.message} type={toast.type} isVisible={toast.isVisible} onClose={() => setToast({ ...toast, isVisible: false })} />
    </div>
  );
};

export default EmailEditor;
